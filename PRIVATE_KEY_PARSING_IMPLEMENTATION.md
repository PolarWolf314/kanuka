# OpenSSH Private Key Parsing Implementation

This document contains actionable implementation tickets for adding OpenSSH private key format support to Kanuka. Each ticket is self-contained with full context, acceptance criteria, and implementation steps.

---

## Background & Motivation

### Current State

Kanuka currently only supports RSA private keys in **PEM format** (PKCS#1):

```
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEA...
-----END RSA PRIVATE KEY-----
```

The `LoadPrivateKey()` function in `internal/secrets/keys.go` explicitly checks for `"RSA PRIVATE KEY"` PEM block type and uses `x509.ParsePKCS1PrivateKey()` to parse it.

### The Problem

Many users have existing SSH keys in **OpenSSH format**, which looks like:

```
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAA...
-----END OPENSSH PRIVATE KEY-----
```

This is the default format generated by `ssh-keygen` on modern systems (OpenSSH 7.8+, released 2018). Users who want to reuse their existing SSH keys, or who receive keys from teammates in this format, currently cannot use them with Kanuka.

### Why This Matters

1. **Reduced friction** - Users with existing `~/.ssh/id_rsa` files in OpenSSH format can use them directly
2. **Consistency** - Kanuka already supports OpenSSH format for *public* keys via `parseSSHPublicKey()` in `keys.go`
3. **Piping support** - Enables workflows like `cat key | kanuka ...` or reading keys from secure vaults
4. **Future flexibility** - Opens the door for `--private-key` flags on commands if needed

### Scope

This implementation focuses on:
- Parsing OpenSSH format private keys
- Supporting passphrase-protected keys with interactive prompting
- Maintaining backward compatibility with existing PEM format
- Adding a helper function for parsing private key content from bytes/string
- Adding CLI support for piping private keys via stdin

**Out of scope:**
- Non-RSA key types (Ed25519, ECDSA) - See [PKP-008](#pkp-008-document-rsa-only-design-decision) for rationale

---

## Ticket Overview

| Ticket | Description | Priority | Effort | Dependencies |
|--------|-------------|----------|--------|--------------|
| [PKP-001](#pkp-001-add-openssh-private-key-parsing-function) | Add OpenSSH private key parsing function | HIGH | 2-3 hours | None |
| [PKP-002](#pkp-002-update-loadprivatekey-to-support-both-formats) | Update LoadPrivateKey to support both formats | HIGH | 1-2 hours | PKP-001 |
| [PKP-003](#pkp-003-add-parseprivatekeytext-helper-function) | Add ParsePrivateKeyText helper function | MEDIUM | 1-2 hours | PKP-001 |
| [PKP-004](#pkp-004-add-comprehensive-test-coverage) | Add comprehensive test coverage | HIGH | 2-3 hours | PKP-001, PKP-002, PKP-003 |
| [PKP-005](#pkp-005-update-documentation) | Update documentation | LOW | 1 hour | PKP-001, PKP-002 |
| [PKP-006](#pkp-006-add-passphrase-protected-key-support) | Add passphrase-protected key support | MEDIUM | 2-3 hours | PKP-001, PKP-002 |
| [PKP-007](#pkp-007-add-private-key-stdin-flag) | Add `--private-key-stdin` flag for piping | LOW | 2-3 hours | PKP-003, PKP-006 |
| [PKP-008](#pkp-008-document-rsa-only-design-decision) | Document RSA-only design decision | LOW | 1 hour | None |

**Recommended implementation order:** PKP-001 → PKP-002 → PKP-003 → PKP-006 → PKP-004 → PKP-007 → PKP-005 → PKP-008

Note: PKP-008 can be done at any time as it has no dependencies.

---

## PKP-001: Add OpenSSH Private Key Parsing Function

### Summary

Create a new function `parseOpenSSHPrivateKey()` that can parse RSA private keys in OpenSSH format.

### Priority

**HIGH** - This is the core functionality that all other tickets depend on.

### Context & Rationale

OpenSSH private keys use a custom binary format that is not compatible with standard PKCS#1 or PKCS#8 PEM parsing. The format is:

1. PEM wrapper with type `"OPENSSH PRIVATE KEY"`
2. Binary payload containing:
   - Magic bytes: `"openssh-key-v1\0"`
   - Cipher name (e.g., `"none"` for unencrypted)
   - KDF name (e.g., `"none"` for unencrypted)
   - KDF options
   - Number of keys
   - Public key(s)
   - Encrypted private key section

Go's `golang.org/x/crypto/ssh` package provides `ssh.ParseRawPrivateKey()` which handles this format.

### Technical Approach

Use the `golang.org/x/crypto/ssh` package which is already an indirect dependency of the project (via `golang.org/x/crypto/nacl/secretbox`).

### Acceptance Criteria

- [ ] New function `parseOpenSSHPrivateKey(data []byte, passphrase []byte) (*rsa.PrivateKey, error)` exists
- [ ] Function correctly parses unencrypted OpenSSH format RSA keys
- [ ] Function correctly parses passphrase-protected keys when passphrase is provided
- [ ] Function returns a specific error type for encrypted keys when no passphrase provided
- [ ] Function returns clear error for non-RSA key types (Ed25519, ECDSA)
- [ ] Function is not exported (internal implementation detail)
- [ ] Unit tests verify parsing of valid OpenSSH keys
- [ ] Unit tests verify appropriate errors for unsupported cases

### Implementation Steps

#### Step 1: Add the ssh package import

In `internal/secrets/keys.go`, add the import:

```go
import (
    // ... existing imports ...
    "golang.org/x/crypto/ssh"
)
```

Run `go mod tidy` to ensure the dependency is properly tracked.

#### Step 2: Create the parsing function

Add to `internal/secrets/keys.go`:

```go
// ErrPassphraseRequired is returned when a key is encrypted and requires a passphrase.
var ErrPassphraseRequired = errors.New("private key is passphrase-protected")

// parseOpenSSHPrivateKey parses an OpenSSH format private key.
// If the key is encrypted and passphrase is nil, returns ErrPassphraseRequired.
// Only RSA keys are supported.
func parseOpenSSHPrivateKey(data []byte, passphrase []byte) (*rsa.PrivateKey, error) {
    var key interface{}
    var err error

    if passphrase != nil {
        key, err = ssh.ParseRawPrivateKeyWithPassphrase(data, passphrase)
    } else {
        key, err = ssh.ParseRawPrivateKey(data)
    }

    if err != nil {
        // Check if it's a passphrase error
        if strings.Contains(err.Error(), "passphrase") ||
           strings.Contains(err.Error(), "encrypted") ||
           strings.Contains(err.Error(), "this private key is passphrase protected") {
            return nil, ErrPassphraseRequired
        }
        return nil, fmt.Errorf("failed to parse OpenSSH private key: %w", err)
    }

    // Type assert to RSA private key
    rsaKey, ok := key.(*rsa.PrivateKey)
    if !ok {
        return nil, fmt.Errorf("unsupported key type: only RSA keys are supported, got %T", key)
    }

    return rsaKey, nil
}
```

#### Step 3: Add unit tests

Create `internal/secrets/keys_openssh_test.go`:

```go
package secrets

import (
    "testing"
)

// Test key constants - generate fresh ones for actual tests
const testOpenSSHPrivateKey = `-----BEGIN OPENSSH PRIVATE KEY-----
... (valid test key) ...
-----END OPENSSH PRIVATE KEY-----`

func TestParseOpenSSHPrivateKey_ValidRSA(t *testing.T) {
    // Test parsing a valid unencrypted RSA key in OpenSSH format
}

func TestParseOpenSSHPrivateKey_EncryptedKey(t *testing.T) {
    // Test that encrypted keys return appropriate error
}

func TestParseOpenSSHPrivateKey_Ed25519Key(t *testing.T) {
    // Test that Ed25519 keys return appropriate error
}

func TestParseOpenSSHPrivateKey_InvalidData(t *testing.T) {
    // Test that invalid data returns appropriate error
}
```

### Files to Modify

- `internal/secrets/keys.go` - Add parsing function
- `internal/secrets/keys_openssh_test.go` - New test file (or add to existing keys test file)
- `go.mod` / `go.sum` - May need updating after `go mod tidy`

### Testing Checklist

```bash
# Generate test keys for testing (do not commit private keys!)
ssh-keygen -t rsa -b 2048 -f test_openssh_key -N ""  # Unencrypted
ssh-keygen -t rsa -b 2048 -f test_encrypted_key -N "password"  # Encrypted
ssh-keygen -t ed25519 -f test_ed25519_key -N ""  # Wrong type

# Run unit tests
go test -v ./internal/secrets/... -run TestParseOpenSSH

# Verify build
go build -v ./...

# Run linter
golangci-lint run
```

---

## PKP-002: Update LoadPrivateKey to Support Both Formats

### Summary

Modify the existing `LoadPrivateKey()` function to automatically detect and parse both PEM (PKCS#1) and OpenSSH format private keys.

### Priority

**HIGH** - This integrates the new parsing into the existing codebase without breaking changes.

### Context & Rationale

The current `LoadPrivateKey()` function is used by multiple commands:
- `secrets decrypt` - Loads private key to decrypt symmetric key
- `secrets encrypt` - Loads private key to decrypt symmetric key
- `secrets register` - Loads private key to decrypt symmetric key for re-encryption
- `secrets revoke` - Loads private key for key rotation

All these commands use the same code path, so updating `LoadPrivateKey()` automatically enables OpenSSH support everywhere.

### Current Implementation

```go
func LoadPrivateKey(path string) (*rsa.PrivateKey, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }
    block, _ := pem.Decode(data)
    if block == nil || block.Type != "RSA PRIVATE KEY" {
        return nil, fmt.Errorf("failed to decode PEM block containing private key")
    }
    return x509.ParsePKCS1PrivateKey(block.Bytes)
}
```

### Acceptance Criteria

- [ ] `LoadPrivateKey()` successfully loads PEM format keys (backward compatible)
- [ ] `LoadPrivateKey()` successfully loads OpenSSH format keys
- [ ] Error messages clearly indicate the issue (wrong format, encrypted, wrong type)
- [ ] All existing tests continue to pass
- [ ] `secrets decrypt` works with OpenSSH format keys
- [ ] `secrets encrypt` works with OpenSSH format keys
- [ ] Integration tests added for OpenSSH key loading

### Implementation Steps

#### Step 1: Update LoadPrivateKey function

Replace the current implementation in `internal/secrets/keys.go`:

```go
// LoadPrivateKey loads an RSA private key from disk.
// Supports both PEM (PKCS#1) and OpenSSH formats.
func LoadPrivateKey(path string) (*rsa.PrivateKey, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }

    return ParsePrivateKeyBytes(data)
}

// ParsePrivateKeyBytes parses an RSA private key from bytes.
// Supports both PEM (PKCS#1) and OpenSSH formats.
func ParsePrivateKeyBytes(data []byte) (*rsa.PrivateKey, error) {
    // Try to decode as PEM
    block, _ := pem.Decode(data)
    if block == nil {
        return nil, fmt.Errorf("failed to decode PEM block from private key data")
    }

    // Check the PEM block type to determine format
    switch block.Type {
    case "RSA PRIVATE KEY":
        // Traditional PEM format (PKCS#1)
        return x509.ParsePKCS1PrivateKey(block.Bytes)

    case "PRIVATE KEY":
        // PKCS#8 format
        key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
        if err != nil {
            return nil, fmt.Errorf("failed to parse PKCS#8 private key: %w", err)
        }
        rsaKey, ok := key.(*rsa.PrivateKey)
        if !ok {
            return nil, fmt.Errorf("PKCS#8 key is not an RSA key, got %T", key)
        }
        return rsaKey, nil

    case "OPENSSH PRIVATE KEY":
        // OpenSSH format
        return parseOpenSSHPrivateKey(data)

    default:
        return nil, fmt.Errorf("unsupported private key format: %s", block.Type)
    }
}
```

#### Step 2: Verify backward compatibility

Run all existing tests to ensure PEM format keys still work:

```bash
go test -v ./...
```

#### Step 3: Add integration tests

Create tests in `test/integration/` that verify the decrypt and encrypt commands work with OpenSSH format keys.

### Files to Modify

- `internal/secrets/keys.go` - Update LoadPrivateKey, add ParsePrivateKeyBytes

### Testing Checklist

```bash
# Run all existing tests (ensure backward compatibility)
go test -v ./...

# Manual testing with OpenSSH key
# 1. Generate OpenSSH format key
ssh-keygen -t rsa -b 2048 -f ~/.config/kanuka/keys/test-project/privkey -N ""

# 2. Try decrypt command
kanuka secrets decrypt

# Run linter
golangci-lint run
```

---

## PKP-003: Add ParsePrivateKeyText Helper Function

### Summary

Add a `ParsePrivateKeyText()` function that parses private key content from a string, mirroring the existing `ParsePublicKeyText()` function.

### Priority

**MEDIUM** - Useful for future features (piping, `--private-key` flags) but not immediately required.

### Context & Rationale

Kanuka already has `ParsePublicKeyText()` which accepts a string containing a public key in either PEM or OpenSSH format. Adding an equivalent for private keys provides:

1. **Consistency** - Similar API for public and private key parsing
2. **Future flexibility** - Enables features like:
   - `--private-key` flag to specify key content directly
   - Reading keys from environment variables
   - Piping key content from secure vaults (e.g., `vault read ... | kanuka ...`)

### Acceptance Criteria

- [ ] New function `ParsePrivateKeyText(privateKeyText string) (*rsa.PrivateKey, error)` exists
- [ ] Function handles PEM format (PKCS#1 and PKCS#8)
- [ ] Function handles OpenSSH format
- [ ] Function trims whitespace from input
- [ ] Function returns clear errors for unsupported formats
- [ ] Unit tests cover all supported formats
- [ ] Function is exported (public API)

### Implementation Steps

#### Step 1: Add the function

In `internal/secrets/keys.go`:

```go
// ParsePrivateKeyText parses a PEM-encoded or OpenSSH format private key string
// and returns an RSA private key.
func ParsePrivateKeyText(privateKeyText string) (*rsa.PrivateKey, error) {
    // Ensure the text is trimmed of whitespace
    privateKeyText = strings.TrimSpace(privateKeyText)

    if privateKeyText == "" {
        return nil, errors.New("private key text is empty")
    }

    // Check that it looks like a PEM-encoded key
    if !strings.HasPrefix(privateKeyText, "-----BEGIN") {
        return nil, errors.New("private key text does not appear to be in PEM format")
    }

    return ParsePrivateKeyBytes([]byte(privateKeyText))
}
```

#### Step 2: Add unit tests

```go
func TestParsePrivateKeyText_PKCS1(t *testing.T) {
    // Test PEM PKCS#1 format
}

func TestParsePrivateKeyText_PKCS8(t *testing.T) {
    // Test PEM PKCS#8 format
}

func TestParsePrivateKeyText_OpenSSH(t *testing.T) {
    // Test OpenSSH format
}

func TestParsePrivateKeyText_EmptyString(t *testing.T) {
    // Test empty input
}

func TestParsePrivateKeyText_InvalidFormat(t *testing.T) {
    // Test non-PEM input
}

func TestParsePrivateKeyText_WhitespaceHandling(t *testing.T) {
    // Test that leading/trailing whitespace is handled
}
```

### Files to Modify

- `internal/secrets/keys.go` - Add ParsePrivateKeyText function
- `internal/secrets/keys_test.go` - Add unit tests

### Testing Checklist

```bash
# Run unit tests
go test -v ./internal/secrets/... -run TestParsePrivateKeyText

# Run linter
golangci-lint run
```

---

## PKP-004: Add Comprehensive Test Coverage

### Summary

Add comprehensive unit and integration tests for all OpenSSH private key parsing functionality.

### Priority

**HIGH** - Testing is critical for cryptographic code.

### Context & Rationale

Private key handling is security-critical. We need thorough tests to ensure:
- All supported formats work correctly
- Error cases are handled appropriately
- No regressions occur when the code is modified

### Acceptance Criteria

- [ ] Unit tests for `parseOpenSSHPrivateKey()` function
- [ ] Unit tests for `ParsePrivateKeyBytes()` function
- [ ] Unit tests for `ParsePrivateKeyText()` function
- [ ] Unit tests for updated `LoadPrivateKey()` function
- [ ] Integration tests for decrypt command with OpenSSH keys
- [ ] Integration tests for encrypt command with OpenSSH keys
- [ ] Tests use dynamically generated keys (not hardcoded)
- [ ] Tests cover error cases (encrypted keys, wrong types, invalid data)
- [ ] All tests pass with `go test -race` (race detector)

### Test Cases to Cover

#### Unit Tests

| Test Case | Description |
|-----------|-------------|
| Valid RSA OpenSSH key | Parse a valid unencrypted RSA key in OpenSSH format |
| Valid RSA PEM PKCS#1 | Parse a valid key in traditional PEM format |
| Valid RSA PEM PKCS#8 | Parse a valid key in PKCS#8 PEM format |
| Encrypted OpenSSH key | Return clear error for passphrase-protected key |
| Ed25519 key | Return clear error for non-RSA key type |
| ECDSA key | Return clear error for non-RSA key type |
| Empty input | Return clear error for empty data |
| Invalid PEM | Return clear error for malformed PEM |
| Non-PEM data | Return clear error for non-PEM input |
| Corrupted key data | Return clear error for corrupted binary data |

#### Integration Tests

| Test Case | Description |
|-----------|-------------|
| Decrypt with OpenSSH key | Full decrypt workflow using OpenSSH format key |
| Encrypt with OpenSSH key | Full encrypt workflow using OpenSSH format key |
| Register with OpenSSH key | Registration workflow with OpenSSH format key |
| Mixed key formats | Project with users having different key formats |

### Implementation Steps

#### Step 1: Create test key generation helpers

In `test/integration/shared/testing_utils.go`, add:

```go
// GenerateOpenSSHKeyPair generates an RSA key pair and saves in OpenSSH format.
func GenerateOpenSSHKeyPair(privatePath, publicPath string) error {
    // Generate RSA key
    privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
    if err != nil {
        return err
    }

    // Convert to OpenSSH format using ssh.MarshalPrivateKey
    // ...
}
```

#### Step 2: Add unit tests

Create `internal/secrets/keys_private_test.go` with comprehensive unit tests.

#### Step 3: Add integration tests

Create `test/integration/decrypt/decrypt_openssh_key_test.go` and similar for other commands.

### Files to Create/Modify

- `internal/secrets/keys_private_test.go` - New unit test file
- `test/integration/shared/testing_utils.go` - Add OpenSSH key generation helpers
- `test/integration/decrypt/decrypt_openssh_key_test.go` - New integration tests
- `test/integration/encrypt/encrypt_openssh_key_test.go` - New integration tests

### Testing Checklist

```bash
# Run all unit tests
go test -v ./internal/secrets/...

# Run all integration tests
go test -v ./test/integration/...

# Run with race detector
go test -race -v ./...

# Run linter
golangci-lint run
```

---

## PKP-005: Update Documentation

### Summary

Update user-facing documentation to reflect OpenSSH private key support.

### Priority

**LOW** - Documentation update after implementation is complete.

### Context & Rationale

Users need to know that Kanuka now supports OpenSSH format private keys. This affects:
- Users trying to use existing SSH keys
- Users receiving keys from teammates
- Troubleshooting guidance

### Acceptance Criteria

- [ ] FAQ updated with supported key formats
- [ ] Any error message changes reflected in docs
- [ ] Troubleshooting section covers common key format issues

### Documentation Updates

#### FAQ Addition

Add to `docs/src/content/docs/reference/faq.md`:

```markdown
## What private key formats does Kanuka support?

Kanuka supports RSA private keys in the following formats:

1. **PEM PKCS#1** - Traditional OpenSSL format
   ```
   -----BEGIN RSA PRIVATE KEY-----
   ```

2. **PEM PKCS#8** - Newer OpenSSL format
   ```
   -----BEGIN PRIVATE KEY-----
   ```

3. **OpenSSH** - Default format from modern ssh-keygen
   ```
   -----BEGIN OPENSSH PRIVATE KEY-----
   ```

Passphrase-protected keys are supported - Kanuka will prompt you for your passphrase
when needed.

Only RSA keys are supported. Ed25519 and ECDSA keys are not compatible with Kanuka.
See [Why does Kanuka only support RSA keys?](#why-does-kanuka-only-support-rsa-keys) for details.
```

#### Troubleshooting Section

Consider adding a troubleshooting guide for common key issues:

```markdown
## Troubleshooting Key Issues

### "unsupported private key format"

Your key may be in an unsupported format. Kanuka only supports RSA keys.
Check your key type:

```bash
ssh-keygen -l -f your_key
```

If it shows `ED25519` or `ECDSA`, you'll need to generate an RSA key instead.

### "cannot read passphrase: stdin is not a terminal"

This error occurs when Kanuka needs to prompt for a passphrase but is running in a
non-interactive environment (e.g., a script or CI pipeline).

Options:
1. Use an unencrypted key for automation
2. Use `--private-key-stdin` to pipe the key from a secrets manager
```

### Files to Modify

- `docs/src/content/docs/reference/faq.md` - Add key format FAQ

### Testing Checklist

```bash
# Build docs locally to verify
cd docs && pnpm dev

# Check for broken links
# (manual review)
```

---

## PKP-006: Add Passphrase-Protected Key Support

### Summary

Add support for passphrase-protected private keys by prompting the user for their passphrase when an encrypted key is detected.

### Priority

**MEDIUM** - Improves usability for users with passphrase-protected keys, which is a security best practice.

### Context & Rationale

Many users protect their private keys with passphrases, which is recommended security practice. Currently, if a user has a passphrase-protected key, they would need to remove the passphrase before using it with Kanuka. This is:

1. **Inconvenient** - Extra step for users
2. **Reduces security** - Encourages removing passphrases from keys
3. **Inconsistent with expectations** - SSH and other tools prompt for passphrases

The `golang.org/x/crypto/ssh` package provides `ssh.ParseRawPrivateKeyWithPassphrase()` which handles decryption of passphrase-protected keys.

### User Experience

When a user runs a command that requires their private key:

```bash
$ kanuka secrets decrypt
Enter passphrase for private key: ********
✓ Environment files decrypted successfully!
```

If the passphrase is incorrect:

```bash
$ kanuka secrets decrypt
Enter passphrase for private key: ********
✗ Incorrect passphrase. Please try again.
Enter passphrase for private key: ********
✓ Environment files decrypted successfully!
```

### Acceptance Criteria

- [ ] Kanuka detects when a private key is passphrase-protected
- [ ] User is prompted for passphrase with hidden input (no echo)
- [ ] Passphrase is read securely (not visible in terminal)
- [ ] User gets up to 3 attempts before command fails
- [ ] Clear error message on final failure
- [ ] Works for all commands that use private keys:
  - [ ] `secrets decrypt`
  - [ ] `secrets encrypt`
  - [ ] `secrets register`
  - [ ] `secrets revoke`
- [ ] Passphrase is not logged or stored
- [ ] Works in non-TTY environments (fails gracefully with clear message)
- [ ] Unit tests cover passphrase prompting logic
- [ ] Integration tests verify end-to-end passphrase flow

### Implementation Steps

#### Step 1: Add terminal input helper

Create a helper function for secure passphrase input in `internal/secrets/keys.go` or a new file `internal/utils/terminal.go`:

```go
package utils

import (
    "fmt"
    "os"
    "syscall"

    "golang.org/x/term"
)

// ReadPassphrase prompts the user for a passphrase without echoing input.
// Returns an error if stdin is not a terminal.
func ReadPassphrase(prompt string) ([]byte, error) {
    fd := int(syscall.Stdin)
    
    if !term.IsTerminal(fd) {
        return nil, fmt.Errorf("cannot read passphrase: stdin is not a terminal")
    }

    fmt.Fprint(os.Stderr, prompt)
    passphrase, err := term.ReadPassword(fd)
    fmt.Fprintln(os.Stderr) // Add newline after hidden input
    
    if err != nil {
        return nil, fmt.Errorf("failed to read passphrase: %w", err)
    }
    
    return passphrase, nil
}
```

#### Step 2: Update LoadPrivateKey to handle passphrase prompting

Modify `LoadPrivateKey()` to detect encrypted keys and prompt for passphrase:

```go
// LoadPrivateKey loads an RSA private key from disk.
// If the key is passphrase-protected, prompts the user for the passphrase.
func LoadPrivateKey(path string) (*rsa.PrivateKey, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }

    return ParsePrivateKeyBytesWithPrompt(data)
}

// ParsePrivateKeyBytesWithPrompt parses a private key, prompting for passphrase if needed.
func ParsePrivateKeyBytesWithPrompt(data []byte) (*rsa.PrivateKey, error) {
    // First attempt without passphrase
    key, err := ParsePrivateKeyBytes(data, nil)
    if err == nil {
        return key, nil
    }

    // Check if passphrase is required
    if !errors.Is(err, ErrPassphraseRequired) {
        return nil, err
    }

    // Prompt for passphrase (up to 3 attempts)
    maxAttempts := 3
    for attempt := 1; attempt <= maxAttempts; attempt++ {
        passphrase, promptErr := utils.ReadPassphrase("Enter passphrase for private key: ")
        if promptErr != nil {
            return nil, promptErr
        }

        key, err = ParsePrivateKeyBytes(data, passphrase)
        if err == nil {
            return key, nil
        }

        if errors.Is(err, ErrPassphraseRequired) || strings.Contains(err.Error(), "incorrect passphrase") {
            if attempt < maxAttempts {
                fmt.Fprintln(os.Stderr, color.YellowString("✗")+" Incorrect passphrase. Please try again.")
            }
            continue
        }

        // Some other error
        return nil, err
    }

    return nil, fmt.Errorf("failed to decrypt private key after %d attempts", maxAttempts)
}
```

#### Step 3: Update ParsePrivateKeyBytes signature

Update the function to accept an optional passphrase:

```go
// ParsePrivateKeyBytes parses an RSA private key from bytes.
// If passphrase is provided, attempts to decrypt passphrase-protected keys.
func ParsePrivateKeyBytes(data []byte, passphrase []byte) (*rsa.PrivateKey, error) {
    // ... existing implementation with passphrase support
}
```

#### Step 4: Add tests

Create tests for passphrase functionality:

```go
func TestLoadPrivateKey_PassphraseProtected(t *testing.T) {
    // Generate a passphrase-protected key
    // Mock terminal input
    // Verify key is loaded correctly
}

func TestLoadPrivateKey_WrongPassphrase(t *testing.T) {
    // Test that wrong passphrase prompts again
}

func TestLoadPrivateKey_NonTTY(t *testing.T) {
    // Test graceful failure in non-interactive environment
}
```

### Files to Modify

- `internal/secrets/keys.go` - Update key loading functions
- `internal/utils/terminal.go` - New file for terminal helpers
- `go.mod` - Add `golang.org/x/term` dependency
- `internal/secrets/keys_test.go` - Add passphrase tests

### Security Considerations

1. **Passphrase not stored** - Passphrase is only held in memory during decryption
2. **No echo** - Passphrase input is not displayed on screen
3. **Memory clearing** - Consider zeroing passphrase bytes after use (Go doesn't guarantee this)
4. **No logging** - Passphrase must never be logged

### Testing Checklist

```bash
# Generate test key with passphrase
ssh-keygen -t rsa -b 2048 -f test_key -N "testpassword"

# Test interactive passphrase entry
kanuka secrets decrypt

# Test wrong passphrase handling
# (enter wrong passphrase, then correct one)

# Test non-TTY environment
echo "" | kanuka secrets decrypt  # Should fail gracefully

# Run unit tests
go test -v ./internal/secrets/... -run TestPassphrase

# Run linter
golangci-lint run
```

---

## PKP-007: Add `--private-key-stdin` Flag for Piping

### Summary

Add a `--private-key-stdin` flag to commands that require private keys, allowing users to pipe key content from external sources like secret managers or vaults.

### Priority

**LOW** - Advanced feature for automation and integration with secret management tools.

### Context & Rationale

In production environments, private keys are often stored in secret management systems like:
- HashiCorp Vault
- AWS Secrets Manager
- Azure Key Vault
- 1Password CLI
- pass (password-store)

Users want to pipe keys directly from these tools without writing to disk:

```bash
vault read -field=private_key secret/kanuka | kanuka secrets decrypt --private-key-stdin
```

This avoids:
1. Writing sensitive keys to disk
2. Managing temporary files
3. Exposure in shell history (the key content isn't in the command)

### User Experience

```bash
# Pipe from vault
vault read -field=private_key secret/kanuka | kanuka secrets decrypt --private-key-stdin

# Pipe from 1Password
op read "op://Vault/Kanuka/private_key" | kanuka secrets decrypt --private-key-stdin

# Pipe from file (less common, but supported)
cat ~/.ssh/id_rsa | kanuka secrets decrypt --private-key-stdin

# With passphrase (reads key from stdin, prompts for passphrase on TTY)
cat encrypted_key.pem | kanuka secrets decrypt --private-key-stdin
Enter passphrase for private key: ********
```

### Acceptance Criteria

- [ ] `--private-key-stdin` flag available on:
  - [ ] `secrets decrypt`
  - [ ] `secrets encrypt`
  - [ ] `secrets register`
  - [ ] `secrets revoke`
- [ ] Flag reads entire stdin as private key content
- [ ] Works with all supported key formats (PEM, OpenSSH)
- [ ] Works with passphrase-protected keys (prompts on stderr/tty)
- [ ] Mutually exclusive with default key loading (clear error if both attempted)
- [ ] Clear error message if stdin is empty
- [ ] Clear error message if key format is invalid
- [ ] Does not interfere with normal command operation when flag not used
- [ ] Integration tests verify piping workflows
- [ ] Documentation updated with examples

### Implementation Steps

#### Step 1: Add flag to commands

In each command file (e.g., `cmd/secrets_decrypt.go`):

```go
var (
    decryptDryRun        bool
    decryptPrivateKeyStdin bool
)

func init() {
    decryptCmd.Flags().BoolVar(&decryptDryRun, "dry-run", false, "preview decryption without making changes")
    decryptCmd.Flags().BoolVar(&decryptPrivateKeyStdin, "private-key-stdin", false, "read private key from stdin")
}

func resetDecryptCommandState() {
    decryptDryRun = false
    decryptPrivateKeyStdin = false
}
```

#### Step 2: Create stdin reading helper

In `internal/utils/io.go`:

```go
package utils

import (
    "fmt"
    "io"
    "os"
)

// ReadStdin reads all content from stdin.
// Returns an error if stdin is empty or cannot be read.
func ReadStdin() ([]byte, error) {
    stat, err := os.Stdin.Stat()
    if err != nil {
        return nil, fmt.Errorf("failed to stat stdin: %w", err)
    }

    // Check if there's data available on stdin
    if (stat.Mode() & os.ModeCharDevice) != 0 {
        return nil, fmt.Errorf("no data provided on stdin (hint: pipe your private key to this command)")
    }

    data, err := io.ReadAll(os.Stdin)
    if err != nil {
        return nil, fmt.Errorf("failed to read from stdin: %w", err)
    }

    if len(data) == 0 {
        return nil, fmt.Errorf("stdin is empty")
    }

    return data, nil
}
```

#### Step 3: Update command logic

In the command's `RunE` function:

```go
RunE: func(cmd *cobra.Command, args []string) error {
    // ... existing setup ...

    var privateKey *rsa.PrivateKey

    if decryptPrivateKeyStdin {
        // Read private key from stdin
        keyData, err := utils.ReadStdin()
        if err != nil {
            return fmt.Errorf("failed to read private key from stdin: %w", err)
        }

        privateKey, err = secrets.ParsePrivateKeyBytesWithPrompt(keyData)
        if err != nil {
            return fmt.Errorf("failed to parse private key from stdin: %w", err)
        }
    } else {
        // Load from default location
        privateKeyPath := configs.GetPrivateKeyPath(projectUUID)
        var err error
        privateKey, err = secrets.LoadPrivateKey(privateKeyPath)
        if err != nil {
            // ... existing error handling ...
        }
    }

    // ... rest of command using privateKey ...
}
```

#### Step 4: Handle passphrase with stdin key

When reading key from stdin but needing a passphrase, we need to read the passphrase from `/dev/tty` (not stdin, which has the key):

```go
// In utils/terminal.go
func ReadPassphraseFromTTY(prompt string) ([]byte, error) {
    tty, err := os.Open("/dev/tty")
    if err != nil {
        return nil, fmt.Errorf("cannot open /dev/tty for passphrase input: %w", err)
    }
    defer tty.Close()

    fmt.Fprint(os.Stderr, prompt)
    passphrase, err := term.ReadPassword(int(tty.Fd()))
    fmt.Fprintln(os.Stderr)

    if err != nil {
        return nil, fmt.Errorf("failed to read passphrase: %w", err)
    }

    return passphrase, nil
}
```

#### Step 5: Add tests

```go
func TestDecrypt_PrivateKeyStdin(t *testing.T) {
    // Test piping a valid key
}

func TestDecrypt_PrivateKeyStdin_EmptyStdin(t *testing.T) {
    // Test error handling for empty stdin
}

func TestDecrypt_PrivateKeyStdin_InvalidKey(t *testing.T) {
    // Test error handling for invalid key data
}

func TestDecrypt_PrivateKeyStdin_WithPassphrase(t *testing.T) {
    // Test passphrase prompting works with stdin key
}
```

### Files to Modify

- `cmd/secrets_decrypt.go` - Add flag and stdin handling
- `cmd/secrets_encrypt.go` - Add flag and stdin handling
- `cmd/secrets_register.go` - Add flag and stdin handling
- `cmd/secrets_revoke.go` - Add flag and stdin handling
- `internal/utils/io.go` - New file for stdin reading
- `internal/utils/terminal.go` - Add TTY passphrase reading

### Platform Considerations

- **Linux/macOS**: `/dev/tty` is available for passphrase prompting
- **Windows**: May need alternative approach using `CON` or Windows console APIs
- Consider adding a `--passphrase-stdin` flag for fully non-interactive use (reads passphrase from second line of stdin or separate fd)

### Testing Checklist

```bash
# Test basic piping
cat ~/.config/kanuka/keys/project-uuid/privkey | kanuka secrets decrypt --private-key-stdin

# Test with vault (if available)
vault read -field=private_key secret/kanuka | kanuka secrets decrypt --private-key-stdin

# Test empty stdin error
echo "" | kanuka secrets decrypt --private-key-stdin

# Test invalid key error
echo "not a key" | kanuka secrets decrypt --private-key-stdin

# Test passphrase-protected key from stdin
cat encrypted_key.pem | kanuka secrets decrypt --private-key-stdin
# (should prompt for passphrase)

# Run integration tests
go test -v ./test/integration/... -run PrivateKeyStdin

# Run linter
golangci-lint run
```

---

## PKP-008: Document RSA-Only Design Decision

### Summary

Create an Architecture Decision Record (ADR) documenting why Kanuka only supports RSA keys and the rationale for not supporting Ed25519, ECDSA, or other key types.

### Priority

**LOW** - Documentation task that can be done at any time.

### Context & Rationale

Users and contributors may wonder why Kanuka only supports RSA keys when modern alternatives like Ed25519 exist. We should document this decision to:

1. **Explain the reasoning** - Help users understand the trade-offs
2. **Prevent repeated discussions** - Point to documentation instead of re-explaining
3. **Guide future decisions** - Provide context if we ever reconsider
4. **Show intentionality** - Demonstrate this is a deliberate choice, not an oversight

### Acceptance Criteria

- [ ] ADR document created in `docs/` or project root
- [ ] Document explains the decision and rationale
- [ ] Document lists alternatives considered
- [ ] Document explains consequences and trade-offs
- [ ] Document is linked from relevant user-facing docs (FAQ, troubleshooting)
- [ ] Document follows ADR format conventions

### ADR Content

Create `docs/adr/001-rsa-only-key-support.md` or `ADR-001-RSA-ONLY.md` in project root:

```markdown
# ADR-001: RSA-Only Key Support

## Status

Accepted

## Context

Kanuka needs to encrypt/decrypt symmetric keys using asymmetric cryptography. Modern cryptographic
libraries support multiple key types:

- **RSA** (2048, 3072, 4096 bit) - Traditional, widely supported
- **Ed25519** - Modern, fast, compact keys
- **ECDSA** (P-256, P-384, P-521) - Elliptic curve, smaller keys than RSA

We need to decide which key type(s) to support.

## Decision

Kanuka will **only support RSA keys** (minimum 2048-bit).

## Rationale

### 1. Simplicity Over Flexibility

Supporting multiple key types adds significant complexity:

- Multiple code paths for encryption/decryption
- Key type detection and validation
- Different error handling for each type
- More test cases and edge cases
- User confusion about which type to use

For a secrets management tool, simplicity and reliability are more important than flexibility.
Users don't typically have strong preferences about key types - they want their secrets encrypted
securely.

### 2. RSA is Sufficient for the Use Case

Kanuka's use case is encrypting symmetric keys (32 bytes) for secure storage. RSA-2048 provides:

- 112 bits of security (sufficient for current threats)
- Well-understood security properties
- Decades of cryptanalysis
- No known practical attacks

The performance advantages of Ed25519 are irrelevant for this use case - we're encrypting
small amounts of data infrequently.

### 3. Universal Tooling Support

RSA keys can be generated and managed with any SSH/OpenSSL tooling:

- `ssh-keygen -t rsa`
- `openssl genrsa`
- All SSH clients and servers
- All major programming languages

While Ed25519 support is growing, RSA remains the most universally supported option.

### 4. Encryption Capability

RSA supports direct encryption of data (via PKCS#1 v1.5 or OAEP). Ed25519 is a **signature**
algorithm only - it cannot encrypt data directly. Using Ed25519 for encryption requires:

- Converting to X25519 (Curve25519 for Diffie-Hellman)
- Implementing ECIES (Elliptic Curve Integrated Encryption Scheme)
- Additional complexity and potential for implementation errors

RSA's direct encryption capability makes the implementation simpler and easier to audit.

### 5. Existing Ecosystem Compatibility

Many users have existing RSA keys from:

- SSH access to servers
- Git authentication
- Previous security tools

Supporting RSA allows users to potentially reuse existing keys (though we recommend dedicated
keys for Kanuka).

## Alternatives Considered

### Support Ed25519 Only

**Rejected** because:
- Ed25519 cannot encrypt directly (signature-only algorithm)
- Would require implementing ECIES, adding complexity
- Less universal tooling support
- No practical benefit for our use case

### Support Multiple Key Types

**Rejected** because:
- Adds significant implementation complexity
- Increases testing burden
- Creates user confusion
- No compelling benefit for the use case
- "Flexible" often means "more ways to misconfigure"

### Use Hybrid Approach (Ed25519 + X25519)

**Rejected** because:
- More complex implementation
- Harder to audit for security
- Ed25519 to X25519 conversion adds attack surface
- RSA already solves the problem adequately

## Consequences

### Positive

- Simpler codebase, easier to maintain and audit
- Clear user guidance (no choices to make)
- Universal compatibility with existing tools
- Well-understood security properties

### Negative

- Users with only Ed25519 keys must generate RSA keys for Kanuka
- Cannot leverage Ed25519's smaller key sizes
- May appear "outdated" to users who prefer modern algorithms

### Neutral

- Performance is identical for practical purposes (encrypting 32 bytes is instant regardless)
- Security level is equivalent (RSA-2048 ≈ 112 bits, Ed25519 ≈ 128 bits, both sufficient)

## Notes

This decision can be revisited if:

1. RSA is deprecated or broken (unlikely in foreseeable future)
2. User demand for Ed25519 becomes overwhelming
3. A clean abstraction emerges that doesn't add significant complexity

Until then, RSA-only support is the right trade-off for Kanuka's goals of simplicity and
reliability.
```

### Files to Create

- `docs/adr/001-rsa-only-key-support.md` or `ADR-001-RSA-ONLY.md`

### Documentation Updates

Update `docs/src/content/docs/reference/faq.md` to link to the ADR:

```markdown
## Why does Kanuka only support RSA keys?

Kanuka intentionally supports only RSA keys to keep the implementation simple and reliable.
RSA provides sufficient security for encrypting symmetric keys, works with all existing
SSH tooling, and supports direct encryption (unlike Ed25519 which is signature-only).

For the full rationale, see [ADR-001: RSA-Only Key Support](/adr/001-rsa-only-key-support).
```

### Testing Checklist

```bash
# Verify markdown renders correctly
cd docs && pnpm dev

# Check links work
# (manual review)

# Verify ADR follows conventions
# (manual review of format)
```

---

## Appendix: OpenSSH Private Key Format Details

### Format Structure

OpenSSH private keys use a custom binary format wrapped in PEM:

```
-----BEGIN OPENSSH PRIVATE KEY-----
[base64-encoded binary data]
-----END OPENSSH PRIVATE KEY-----
```

The binary data contains:

1. **Auth magic** (15 bytes): `"openssh-key-v1\0"`
2. **Cipher name** (string): e.g., `"none"` or `"aes256-ctr"`
3. **KDF name** (string): e.g., `"none"` or `"bcrypt"`
4. **KDF options** (string): Empty for unencrypted, contains salt/rounds for encrypted
5. **Number of keys** (uint32): Usually 1
6. **Public key** (string): The public key in SSH wire format
7. **Private key section**: Encrypted or plaintext depending on cipher

### Why Use golang.org/x/crypto/ssh

The `ssh.ParseRawPrivateKey()` and `ssh.ParseRawPrivateKeyWithPassphrase()` functions handle all the complexity of:
- Parsing the binary format
- Detecting encrypted keys
- Decrypting passphrase-protected keys
- Extracting the RSA private key components
- Validating the key structure

This is the same package used by the Go SSH client/server implementations, so it's well-tested and maintained.

---

## Implementation Notes

### Backward Compatibility

All changes are backward compatible:
- Existing PEM format keys continue to work
- No changes to file storage format
- No changes to command-line interface
- No configuration changes required

### Security Considerations

1. **Passphrase handling** - Passphrases are read securely (no echo), held only in memory during decryption, and should be zeroed after use
2. **RSA only** - We only support RSA to maintain consistency with existing Kanuka cryptographic operations (see [PKP-008](#pkp-008-document-rsa-only-design-decision))
3. **Key validation** - The ssh package validates key structure before returning
4. **Stdin security** - When reading keys from stdin, the key content is not exposed in command history or process lists

### Dependencies

The `golang.org/x/crypto/ssh` package is already an indirect dependency of the project through `golang.org/x/crypto/nacl/secretbox`. Adding direct usage should not introduce new dependencies.

```bash
# Verify dependency is already present
go mod graph | grep golang.org/x/crypto
```
