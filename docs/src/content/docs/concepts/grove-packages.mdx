---
title: Package Management
description: An explanation for how Grove manages packages and dependencies.
---

Grove provides access to thousands of packages from the Nix ecosystem without any of the usual dependency headaches. Here's how it all works.

## How Grove handles packages

Grove distinguishes between two types of additions:

### Packages
These are individual tools and applications like `nodejs`, `docker`, or `git`. When you add a package, Grove:

1. Finds the package in the nixpkgs repository.
2. Adds it to your `devenv.nix` file.
3. Updates `kanuka.toml` to track the addition.
4. Includes all necessary dependencies automatically.

### Languages
These are full programming language environments with extra tooling like `typescript`, `rust`, or `go`. Language environments often include:

- The language runtime.
- Package managers (npm, cargo, go mod).
- Language servers for IDE support.
- Common development tools.

## Package resolution

When you run `kanuka grove add nodejs`, here's what happens:

import { Steps } from '@astrojs/starlight/components';

<Steps>

1. Grove searches the nixpkgs repository for a package named "nodejs".
2. Grove finds the latest version (unless you specified a version).
3. Grove adds `pkgs.nodejs` to your `devenv.nix` file.
4. Grove updates `kanuka.toml` with the package name.
5. The next time you enter your environment, Nix downloads the package and all its dependencies.

</Steps>

## Dependency management

One of the biggest advantages of Grove is automatic dependency management:

- **No dependency conflicts**: Each package brings its own dependencies.
- **No system pollution**: Dependencies don't affect your system.
- **Reproducible builds**: Same dependencies everywhere.
- **Automatic resolution**: You never have to manually install dependencies.

For example, when you add `nodejs`, you automatically get:
- The Node.js runtime.
- npm package manager.
- All required system libraries.
- Proper environment variables.

## Version management

Grove handles package versions through several mechanisms:

### Explicit versions
```bash
kanuka grove add nodejs_18  # Specific Node.js version
kanuka grove add python39   # Python 3.9
```

### Channel-based versions
```bash
kanuka grove add nodejs --channel stable    # Stable version
kanuka grove add nodejs --channel unstable  # Latest version
```

### Pinned versions
When you add a package, Grove records the exact version in a lock file, ensuring everyone gets the same version.

## Package sources

Grove gets packages from [nixpkgs](https://github.com/NixOS/nixpkgs), which is:

- **Huge**: Over 100,000 packages available ([browse them here](https://search.nixos.org/packages)).
- **Fresh**: Updated continuously.
- **Tested**: Packages are built and tested automatically.
- **Cached**: Binary packages are pre-built and cached.

## How Grove updates packages

When you run `kanuka grove channel update`:

<Steps>

1. Grove fetches the latest channel definitions.
2. Grove updates the package repository references.
3. The next time you enter your environment, you get updated packages.
4. All dependencies are automatically updated too.

</Steps>

## Package isolation

Each Grove environment has its own package set:

- **Project isolation**: Packages in one project don't affect another.
- **Version isolation**: Different projects can use different versions.
- **Clean environments**: Only declared packages are available.
- **No conflicts**: Multiple versions of the same package can coexist.

This means you can have a project using Node.js 16 and another using Node.js 18, without any conflicts or complex version management.

Continue reading to learn about how channels control package versions.